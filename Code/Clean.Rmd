---
title: "LLM"
output: html_document
date: "2025-11-04"
---

```{r}
library(ellmer);
library(tidyverse);
library(furrr); # for parallel map
library(kableExtra);
library(jsonlite)
library(dplyr)
library(readr)
library(httr2)
library(purrr)
library(tibble)
library(stringr)
```
```{r}
ctg_studies <- read_csv("../Data/ctg-studies.csv")
cancer <- read_csv("Data/cancer.csv")
```
```{r}
unique(cancer$cause)
```
```{r}
ctg100 <- head(ctg_studies, 100)

```

```{r}
format_table <- function(df, max_length = 150) {
  head_df <- data.frame(df %>% head(5))
  # Function to truncate individual text entries
  truncate_text <- function(text, max_length) {
    text <- gsub("[\r\n]", "", text)
    return (
      ifelse(nchar(text) > max_length, 
             paste0(substr(text, 1, max_length), "..."), 
             text)
    )
  }
  
  # Loop over all columns that are character type and apply truncation
  for (col in colnames(head_df)) {
    if (is.character(head_df[[col]])) {
      head_df[[col]] <- sapply(head_df[[col]], truncate_text, max_length = max_length)
    }
  }
  
  # Return the modified data frame
  head_df %>%
    kbl() %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size=12)
}

```

```{r}
Sys.setenv(OPENAI_API_KEY = "")
```

## Test

```{r}
allowed_labels <- c(
  "Soft tissue and other extraosseous sarcomas",
  "Malignant neoplasm of bone and articular cartilage",
  "Neuroblastoma and other peripheral nervous cell tumors",
  "Esophageal cancer",
  "Eye cancer",
  "Stomach cancer",
  "Multiple myeloma",
  "Leukemia",
  "Other malignant neoplasms",
  "Other neoplasms",
  "Breast cancer",
  "Cervical cancer",
  "Uterine cancer",
  "Prostate cancer",
  "Colon and rectum cancer",
  "Lip and oral cavity cancer",
  "Nasopharynx cancer",
  "Other pharynx cancer",
  "Gallbladder and biliary tract cancer",
  "Pancreatic cancer",
  "Malignant skin melanoma",
  "Non-melanoma skin cancer",
  "Ovarian cancer",
  "Testicular cancer",
  "Kidney cancer",
  "Bladder cancer",
  "Brain and central nervous system cancer",
  "Thyroid cancer",
  "Mesothelioma",
  "Hodgkin lymphoma",
  "Non-Hodgkin lymphoma",
  "Liver cancer",
  "Larynx cancer",
  "Tracheal, bronchus, and lung cancer"
)
```
```{r}
`%||%` <- function(a, b) if (is.null(a)) b else a

chunk_vec <- function(x, size = 20) split(x, ceiling(seq_along(x) / size))
```

### Function
```{r}
llm_normalize_conditions_one <- function(
  conditions,
  labels = allowed_labels,
  model = "gpt-4.1-mini",
  batch_size = 20,
  temperature = 0
) {
  api_key <- Sys.getenv("OPENAI_API_KEY")
  if (identical(api_key, "")) stop("Set OPENAI_API_KEY via Sys.setenv().", call. = FALSE)

  strict_rules <- paste0(
   "You will map each clinical-trial condition string to EXACTLY ONE canonical cancer label.\n",
  "\nOUTPUT FORMAT\n",
  "- Return a STRICT JSON array of objects, no prose: ",
  "[{\"input\":\"<original>\",\"label\":\"<one label>\"}].\n",
  "- Preserve input order; no extra fields, no code fences.\n",
  "\nPRIORITY & TIE-BREAKS (aim to AVOID 'Other neoplasms')\n",
  "A) If any ORGAN-SITE cancer term appears, map to that organ’s label.\n",
  "B) If only GENERIC cancer context appears (e.g., 'cancer', 'solid tumor', 'metastases' with no site), use 'Neoplasms' (NOT 'Other neoplasms').\n",
  "C) If the string contains a WELL-KNOWN PRECURSOR or STRONG RISK CONDITION, map to the organ site:\n",
  "   - HPV, cervical intraepithelial neoplasia → Cervical cancer\n",
  "   - Barrett esophagus, esophageal dysplasia/stenosis → Esophageal cancer\n",
  "   - Colonic adenoma/adenomatous polyp → Colon and rectum cancer\n",
  "D) If multiple organ sites are present, choose the FIRST organ site mentioned (left-to-right).\n",
  "E) If benign/non-neoplastic but CLEARLY organ-specific and a common neoplastic context in trials (e.g., uterine leiomyoma/fibroid; adenomyosis), map to that organ’s label (e.g., 'Uterine cancer').\n",
  "F) Only use 'Other neoplasms' when: (1) there is NO organ site, NO generic cancer term, and NO recognized precursor/risk term; or (2) the entity is a non-neoplastic growth with no clear organ-site implication (e.g., ganglion cyst) AND no generic cancer context.\n",
  "\nNORMALIZATION RULES\n",
  "1) Labels must EXACTLY match one of the ALLOWED LABELS (case, spaces, punctuation).\n",
  "2) Histology/behavior/stage descriptors (e.g., NSCLC, metastatic, AJCC, adenocarcinoma, squamous) do NOT change organ site.\n",
  "3) 'Hematologic neoplasms' → Leukemia (unless Hodgkin or Non-Hodgkin explicitly appears).\n",
  "4) 'Spinal tumor'/'spinal cord' → Brain and central nervous system cancer.\n",
  "5) Smoking/tobacco exposure with cancer context but no site → Tracheal, bronchus, and lung cancer.\n",
  "6) Bone metastases as the primary focus of treatment/outcome → Malignant neoplasm of bone and articular cartilage.\n",
  "\nKEYWORD → LABEL LEXICON (non-exhaustive; use when present)\n",
  "- lung, bronch, trachea, nsclc, sclc → Tracheal, bronchus, and lung cancer\n",
  "- colon, colorectal, rectum, crc, polyp, adenoma → Colon and rectum cancer\n",
  "- gastric, stomach → Stomach cancer\n",
  "- liver, hcc, hepatocellular → Liver cancer\n",
  "- pancreas, pancreatic → Pancreatic cancer\n",
  "- cervix, cervical, hpv, cin → Cervical cancer\n",
  "- ovary, ovarian, pcos → Ovarian cancer\n",
  "- uterus, uterine, endometrial, fibroid, leiomyoma, adenomyosis → Uterine cancer\n",
  "- prostate, androgen, castration-resistant → Prostate cancer\n",
  "- breast, mammary → Breast cancer\n",
  "- esophag, barrett → Esophageal cancer\n",
  "- thyroid → Thyroid cancer\n",
  "- kidney, renal → Kidney cancer\n",
  "- bladder, urothelial → Bladder cancer\n",
  "- brain, cns, spinal, glioblast → Brain and central nervous system cancer\n",
  "- bone, osteosarcoma → Malignant neoplasm of bone and articular cartilage\n",
  "- melanoma → Malignant skin melanoma; basal cell/squamous cell of skin → Non-melanoma skin cancer\n",
  "- hodgkin → Hodgkin lymphoma; non-hodgkin, nhl → Non-Hodgkin lymphoma\n",
  "- myeloma → Multiple myeloma\n",
  "- sarcoma (soft tissue) → Soft tissue and other extraosseous sarcomas\n",
  "- mesothelioma → Mesothelioma\n",
  "- nasopharynx → Nasopharynx cancer; larynx → Larynx cancer; oral cavity/lip → Lip and oral cavity cancer\n",
  "- gallbladder, biliary → Gallbladder and biliary tract cancer\n",
  "- testis, testicular → Testicular cancer; eye → Eye cancer; thyroid → Thyroid cancer\n",
  "\nFINAL FALLBACK\n",
  "- If none of the above applies and there is no generic cancer context, return 'Other neoplasms'.\n",
  "\nCONSTRAINTS\n",
  "- EXACTLY ONE label per input; label must be one of the ALLOWED LABELS.\n"
  )

 system_prompt <- paste0(
  strict_rules,
  "\nALLOWED LABELS:\n- ",
  paste(allowed_labels, collapse = "\n- ")
)

  # Few-shot to anchor single-label behavior
fewshot_user <- paste0(
  "Map to EXACTLY ONE allowed label:\n",
  "- \"Human Papillomavirus Infections\"\n",
  "- \"Barrett Esophagus | Esophageal Stenosis\"\n",
  "- \"Spinal Tumors, Trauma Patients, Minocycline.\"\n",
  "- \"Treatment of Bone Metastases\"\n",
  "- \"Upper Extremity Deep Vein Thrombosis | Central Venous Catheter Thrombosis | Cancer\"\n",
  "- \"Uterine Myoma, Ovary Neoplasm, Adenomyosis\"\n",
  "- \"Tobacco Smoking\"\n",
  "- \"Hematologic Neoplasms\"\n"
)

fewshot_assistant <- jsonlite::toJSON(list(
  list(input="Human Papillomavirus Infections", label="Cervical cancer"),
  list(input="Barrett Esophagus | Esophageal Stenosis", label="Esophageal cancer"),
  list(input="Spinal Tumors, Trauma Patients, Minocycline.", label="Brain and central nervous system cancer"),
  list(input="Treatment of Bone Metastases", label="Malignant neoplasm of bone and articular cartilage"),
  list(input="Upper Extremity Deep Vein Thrombosis | Central Venous Catheter Thrombosis | Cancer", label="Neoplasms"),
  list(input="Uterine Myoma, Ovary Neoplasm, Adenomyosis", label="Uterine cancer"),
  list(input="Tobacco Smoking", label="Tracheal, bronchus, and lung cancer"),
  list(input="Hematologic Neoplasms", label="Leukemia")
), auto_unbox = TRUE)

  batches <- chunk_vec(conditions, batch_size)

  results <- vector("list", length(conditions))
  names(results) <- seq_along(conditions)
  idx_offset <- 0L

  for (b in batches) {
    idxs <- seq_along(b) + idx_offset
    idx_offset <- idx_offset + length(b)

    user_payload <- list(
      inputs = unname(as.character(b)),
      note = "Return STRICT JSON only; no prose."
    )

    req <- request("https://api.openai.com/v1/chat/completions") |>
      req_headers(
        Authorization = paste("Bearer", api_key),
        `Content-Type` = "application/json"
      ) |>
      req_body_json(list(
        model = model,
        temperature = temperature,
        messages = list(
          list(role = "system", content = system_prompt),
          list(role = "user", content = fewshot_user),
          list(role = "assistant", content = fewshot_assistant),
          list(role = "user", content =
                paste0("Map these inputs (STRICT JSON array only):\n",
                       toJSON(user_payload, auto_unbox = TRUE)))
        )
      ))

    resp <- req_perform(req)
    txt  <- resp_body_string(resp)
    txt_clean <- str_replace_all(txt, "^\\s*```(json)?\\s*|\\s*```\\s*$", "")

    parsed <- tryCatch(jsonlite::fromJSON(txt_clean, simplifyVector = FALSE), error = function(e) NULL)

    # If we got the usual chat envelope, extract content
    if (is.null(parsed) || !is.null(parsed$choices)) {
      content <- parsed$choices[[1]]$message$content
      content <- str_replace_all(content, "^\\s*```(json)?\\s*|\\s*```\\s*$", "")
      parsed  <- tryCatch(jsonlite::fromJSON(content, simplifyVector = FALSE), error = function(e) NULL)
    }

    if (is.null(parsed) || !is.list(parsed)) {
      stop("LLM did not return valid JSON. Raw text:\n", txt)
    }

    for (j in seq_along(parsed)) {
      item <- parsed[[j]]
      lab  <- as.character(item$label %||% NA)

      # Guardrail: keep only allowed, else fallback
      if (!(lab %in% labels)) lab <- "Other neoplasms"

      i_global <- idxs[j]
      results[[as.character(i_global)]] <- list(
        input = as.character(conditions[i_global] %||% NA),
        label = lab
      )
    }
  }

  tibble::tibble(
    row = seq_along(conditions),
    input = conditions,
    Condition_clean = map_chr(results, ~ .x$label %||% "Other neoplasms")
  )
}
```

### Apply
```{r}
clean_map <- llm_normalize_conditions_one(ctg_studies$Conditions)
ctg_clean <- ctg_studies %>% mutate(Condition_clean = clean_map$Condition_clean)


write_csv(ctg_clean, "../Data/ctg_clean.csv")
write_csv(clean_map, "../Data/clean_map.csv")
```
## Clean Sponsor
```{r}

`%||%` <- function(x, y) if (is.null(x) || length(x) == 0) y else x
             
# helper if you don't already have it
chunk_vec <- function(x, size) {
  split(x, ceiling(seq_along(x) / size))
}

llm_normalize_sponsors <- function(
  sponsors,
  model = "gpt-4.1-mini",
  batch_size = 50,
  temperature = 0
) {
  api_key <- Sys.getenv("OPENAI_API_KEY")
  if (identical(api_key, "")) {
    stop("Set OPENAI_API_KEY via Sys.setenv().", call. = FALSE)
  }

  allowed_types <- c(
    "Academic",
    "Hospital / medical center",
    "Industry",
    "Cooperative group / network",
    "Research institute / foundation",
    "Government / public agency",
    "Individual",
    "Other / unknown"
  )

  strict_rules <- paste0(
    "You normalize clinical trial sponsor names.\n",
    "\nTASK\n",
    "For each input sponsor string, output:\n",
    "- \"sponsor_clean\": a canonical, cleaned sponsor name\n",
    "   (fix casing, remove IDs, remove duplicate site descriptors,\n",
    "    keep the main institution or company; no translation).\n",
    "- \"sponsor_type\": ONE of these categories:\n",
    paste0("   - ", allowed_types, collapse = "\n"),
    "\nOUTPUT FORMAT (VERY IMPORTANT)\n",
    "- Return ONLY a STRICT JSON array of objects, no prose, no code fences.\n",
    "- Each object must be:\n",
    "  {\"input\":\"<original>\",\"sponsor_clean\":\"<cleaned>\",\"sponsor_type\":\"<one category>\"}\n",
    "- Preserve input order.\n",
    "- No extra fields.\n",
    "\nCLASSIFICATION RULES\n",
    "1) \"Academic\": Universities, colleges, academic departments, comprehensive cancer centers\n",
    "   primarily embedded in universities.\n",
    "2) \"Hospital / medical center\": General hospitals, university hospitals, cancer hospitals,\n",
    "   health systems, medical centers.\n",
    "3) \"Industry\": Pharmaceutical, biotech, device, diagnostics, or for-profit companies.\n",
    "4) \"Cooperative group / network\": Multi-center oncology groups, trial networks, consortia.\n",
    "5) \"Research institute / foundation\": Independent research institutes, non-profit foundations\n",
    "   primarily focused on research or cancer.\n",
    "6) \"Government / public agency\": NIH, NCI, national health services, ministries, public insurers.\n",
    "7) \"Individual\": A single person’s name without institutional keywords.\n",
    "8) \"Other / unknown\": Anything that does not clearly fit above.\n",
    "\nNORMALIZATION DETAILS\n",
    "- Keep key institutional names (e.g., \"Sun Yat-sen University\").\n",
    "- Drop internal building names, department numbers, or IDs when not essential.\n",
    "- If multiple entities appear (e.g., group + hospital), choose the primary sponsor\n",
    "  (usually the organization whose name dominates or is first).\n",
    "- Do NOT invent organizations; if unclear, lightly clean the string.\n",
    "- Always choose exactly ONE sponsor_type per record from the allowed list.\n",
    "- Be conservative: if unsure between two types, choose \"Other / unknown\".\n"
  )

  system_prompt <- strict_rules

  # few-shot anchors
  fewshot_user <- paste0(
    "Normalize and classify these sponsors:\n",
    "- \"Sun Yat-sen University\"\n",
    "- \"General University Hospital, Prague\"\n",
    "- \"Novartis Pharmaceuticals\"\n",
    "- \"Alliance for Clinical Trials in Oncology\"\n",
    "- \"Medical Research Council\"\n",
    "- \"M.D. Anderson Cancer Center\"\n",
    "- \"Jakob Kristian Jakobsen\"\n"
  )

  fewshot_assistant <- jsonlite::toJSON(list(
    list(
      input = "Sun Yat-sen University",
      sponsor_clean = "Sun Yat-sen University",
      sponsor_type = "Academic"
    ),
    list(
      input = "General University Hospital, Prague",
      sponsor_clean = "General University Hospital, Prague",
      sponsor_type = "Hospital / medical center"
    ),
    list(
      input = "Novartis Pharmaceuticals",
      sponsor_clean = "Novartis Pharmaceuticals",
      sponsor_type = "Industry"
    ),
    list(
      input = "Alliance for Clinical Trials in Oncology",
      sponsor_clean = "Alliance for Clinical Trials in Oncology",
      sponsor_type = "Cooperative group / network"
    ),
    list(
      input = "Medical Research Council",
      sponsor_clean = "Medical Research Council",
      sponsor_type = "Research institute / foundation"
    ),
    list(
      input = "M.D. Anderson Cancer Center",
      sponsor_clean = "MD Anderson Cancer Center",
      sponsor_type = "Hospital / medical center"
    ),
    list(
      input = "Jakob Kristian Jakobsen",
      sponsor_clean = "Jakob Kristian Jakobsen",
      sponsor_type = "Individual"
    )
  ), auto_unbox = TRUE)

  batches <- chunk_vec(sponsors, batch_size)

  results <- vector("list", length(sponsors))
  names(results) <- seq_along(sponsors)
  idx_offset <- 0L

  for (b in batches) {
    idxs <- seq_along(b) + idx_offset
    idx_offset <- idx_offset + length(b)

    user_payload <- list(
      inputs = unname(as.character(b)),
      note = "Return STRICT JSON only; no prose."
    )

    req <- request("https://api.openai.com/v1/chat/completions") |>
      req_headers(
        Authorization = paste("Bearer", api_key),
        `Content-Type` = "application/json"
      ) |>
      req_body_json(list(
        model = model,
        temperature = temperature,
        messages = list(
          list(role = "system", content = system_prompt),
          list(role = "user", content = fewshot_user),
          list(role = "assistant", content = fewshot_assistant),
          list(
            role = "user",
            content = paste0(
              "Normalize these sponsors (STRICT JSON array only):\n",
              toJSON(user_payload, auto_unbox = TRUE)
            )
          )
        )
      ))

    resp <- req_perform(req)
    txt  <- resp_body_string(resp)

    # strip any stray code fences if model misbehaves
    txt_clean <- str_replace_all(
      txt,
      "^\\s*```(json)?\\s*|\\s*```\\s*$",
      ""
    )

    parsed <- tryCatch(
      jsonlite::fromJSON(txt_clean, simplifyVector = FALSE),
      error = function(e) NULL
    )

    # handle normal chat envelope
    if (!is.null(parsed) && !is.null(parsed$choices)) {
      content <- parsed$choices[[1]]$message$content
      content <- str_replace_all(
        content,
        "^\\s*```(json)?\\s*|\\s*```\\s*$",
        ""
      )
      parsed <- tryCatch(
        jsonlite::fromJSON(content, simplifyVector = FALSE),
        error = function(e) NULL
      )
    }

    if (is.null(parsed) || !is.list(parsed)) {
      stop("LLM did not return valid JSON. Raw text:\n", txt)
    }

    for (j in seq_along(parsed)) {
      item <- parsed[[j]]

      sponsor_clean <- as.character(item$sponsor_clean %||% NA)
      sponsor_type  <- as.character(item$sponsor_type %||% NA)

      # Guardrails: enforce sponsor_type ∈ allowed_types
      if (!(sponsor_type %in% allowed_types)) {
        sponsor_type <- "Other / unknown"
      }

      i_global <- idxs[j]
      results[[as.character(i_global)]] <- list(
        Sponsor_raw   = as.character(sponsors[i_global] %||% NA),
        Sponsor_clean = sponsor_clean %||% as.character(sponsors[i_global] %||% NA),
        Sponsor_type  = sponsor_type
      )
    }
  }

  tibble(
    Sponsor_raw   = map_chr(results, ~ .x$Sponsor_raw),
    Sponsor_clean = map_chr(results, ~ .x$Sponsor_clean),
    Sponsor_type  = map_chr(results, ~ .x$Sponsor_type)
  )
}

```
### Apply
```{r}
sp_cleanMap <- llm_normalize_sponsors(ctg100$Sponsor)
```

```{r}
ctg_clean <- read_csv("../Data/ctg_clean.csv")
```
```{r}
glimpse(ctg_clean)
```
```{r}
ctg_clean <- ctg_clean %>%
  mutate(
    # --- Start date cleaning ---
    Start_Date_clean = str_sub(`Start Date`, 1, 7),
    Start_Date_clean = if_else(
      str_detect(Start_Date_clean, "^\\d{4}$"),
      paste0(Start_Date_clean, "-01"),
      Start_Date_clean
    ),
    Start_Date_clean = ym(Start_Date_clean),

    # --- Intervention type cleaning ---
    Intervention_clean = Interventions %>%
      str_extract_all("\\b[A-Z]+(?=:)") %>%
      lapply(unique) %>%
      sapply(\(x) paste(x, collapse = "|")),

    # --- Condition cleaning tweak: Neoplasms → Other neoplasms ---
    Condition_clean = str_replace(
      Condition_clean,
      "\\bNeoplasms\\b",
      "Other neoplasms"
    )
  )
ctg_clean %>%
  count(Condition_clean == "Other neoplasms")
```






